<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>corHMM 2.1: Generalized hidden Markov models • corHMM</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="corHMM 2.1: Generalized hidden Markov models">
<meta property="og:description" content="corHMM">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    

    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">corHMM</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">2.9</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/corHMMv2.1-vignette.html">corHMM 2.1: Generalized hidden Markov models</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>corHMM 2.1: Generalized hidden Markov
models</h1>
                        <h4 data-toc-skip class="author">James D. Boyko
and Jeremy M. Beaulieu</h4>
            
      
      
      <div class="hidden name"><code>corHMMv2.1-vignette.Rmd</code></div>

    </div>

    
    
<p>The vignette is comprised of three sections, where we demonstrate all
new extensions as well as other new and useful features:</p>
<ul>
<li><p><strong>Background information</strong></p></li>
<li>
<p><strong>Section 1 Default use of corHMM</strong></p>
<ul>
<li>1.1: No hidden rate categores</li>
<li>1.2: Any number of hidden rate categories</li>
</ul>
</li>
<li>
<p><strong>Section 2 How to make and interpret custom
models</strong></p>
<ul>
<li>2.1: Creating and using custom rate matrices
<ul>
<li>2.1.1: One rate category</li>
<li>2.1.2: Any number of rate categories</li>
</ul>
</li>
<li>2.2: Some examples of “biologically informed” models
<ul>
<li>2.2.1: Ordered habitat change</li>
<li>2.2.2: Precursor model</li>
<li>2.2.3: Ontological relationship of multiple characters</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Section 3 Estimating models when node states are
fixed</strong></p>
<ul>
<li>3.1: Fixing a single node</li>
<li>3.2: Estimating rates under a parsimony reconstruction</li>
<li>3.3: Fixing nodes when the model contains hidden states</li>
</ul>
</li>
</ul>
<p>#Background information</p>
<p>The original version of <code>corHMM</code> contained a number of
distinct functions for conducting analyses of discrete morphological
characters. This included the <code><a href="../reference/corHMM.html">corHMM()</a></code> function for fitting
a hidden rates model, which uses “hidden” states as a means of allowing
transition rates in a binary character to vary across a tree. In
reality, the hidden rates model falls within a general class of models,
hidden Markov models (HMM), that may also be applied to multistate
characters. So, whether the focal trait is binary or contains multiple
states, or whether the observed states represents a set of binary and
multistate characters, hidden states can be applied as a means of
allowing heterogeneity in the transition model. Choosing a model
specific to your question is of utmost importance in any comparative
method, and in this new version of <code>corHMM</code> we provide users
with the tools to create their own hidden Markov models.</p>
<p>Before delving into this further it may be worth showing a little of
what is underneath the hood. To begin, consider a single binary
character with states <em>0</em> and <em>1</em>. If the question was to
understand the asymmetry in the transition between these two states, the
model, <strong>Q</strong>, would be a simple 2x2 matrix,</p>
<p><span class="math display">\[
Q=
\begin{bmatrix}
-  &amp; q_{0 \rightarrow 1} \\
q_{1 \rightarrow 0} &amp; - \\
\end{bmatrix}
\]</span> This <em>transition rate matrix</em> is read as describing the
transition rate <em>from</em> ROW <em>to</em> COLUMN. Thus, there are
only two states, 0 and 1, and two transitions going from 0 <span class="math inline">\(\rightarrow\)</span> 1, and from 1 <span class="math inline">\(\rightarrow\)</span> 0. However, if we introduce a
second binary character, the number of possible states you
<em>could</em> observe is expanded to account for all the combination of
states between two characters – that is, you could observe <em>00</em>,
<em>01</em>, <em>10</em>, or <em>11</em>. To accommodate this, we need
to expand our model such that it becomes a 4x4 matrix,</p>
<p><span class="math display">\[
Q =
\begin{bmatrix}
-  &amp; q_{00 \rightarrow 01} &amp; q_{00 \rightarrow 10} &amp; q_{00
\rightarrow 11}\\
q_{01 \rightarrow 00} &amp; - &amp; q_{01 \rightarrow 10} &amp; q_{01
\rightarrow 11}\\
q_{10 \rightarrow 00} &amp; q_{10 \rightarrow 01} &amp; - &amp; q_{10
\rightarrow 11}\\
q_{11 \rightarrow 00} &amp; q_{11 \rightarrow 01} &amp; q_{11
\rightarrow 10} &amp; -\\
\end{bmatrix}
\]</span></p>
<p>This model is considerably more complex, as the number of transitions
in this rate matrix now goes from 2 to 12. However, with these models we
often make a simplifying assumption that we do not allow for transitions
in two states to occur at the same time. In other words, if a lineage is
in state <em>00</em> it must first transition to either state
<em>01</em> or <em>10</em>, before transitioning to state <em>11</em>.
Therefore, we can simplify the matrix by removing these “dual”
transitions from the model completely,</p>
<p><span class="math display">\[
Q =
\begin{bmatrix}
-  &amp; q_{00 \rightarrow 01} &amp; q_{00 \rightarrow 10} &amp; -\\
q_{01 \rightarrow 00} &amp; - &amp; - &amp; q_{01 \rightarrow 11}\\
q_{10 \rightarrow 00} &amp; - &amp; - &amp; q_{10 \rightarrow 11}\\
- &amp; q_{11 \rightarrow 01} &amp; q_{11 \rightarrow 10} &amp; -\\
\end{bmatrix}
\]</span></p>
<p>What we just described is the popular model of Pagel (1994), which
tests for correlated evolution between two binary characters. But, one
thing that is not obvious: the states in the model need not be
represented as combinations of binary characters. For example, the focal
character may be two characters, like say, flowers that are red with and
without petals, and blue flowers with and without petals. One could just
code it as a single multistate character, where <em>1</em>=red petals,
<em>2</em>=red with no petals (i.e., sepals are red), <em>3</em>=blue
petals, and <em>4</em>=blue with no petals (i.e., sepals are blue). The
model would then be,</p>
<p><span class="math display">\[
Q =
\begin{bmatrix}
-  &amp; q_{1 \rightarrow 2} &amp; q_{1 \rightarrow 3} &amp; q_{1
\rightarrow 4}\\
q_{2 \rightarrow 1} &amp; - &amp; q_{2 \rightarrow 3} &amp; q_{2
\rightarrow 4}\\
q_{3 \rightarrow 1} &amp; q_{3 \rightarrow 2} &amp; - &amp; q_{3
\rightarrow 4}\\
q_{4 \rightarrow 1} &amp; q_{4 \rightarrow 2} &amp; q_{4 \rightarrow 3}
&amp; -\\
\end{bmatrix}
\]</span></p>
<p>Notice it is the same as before, but the states are transformed from
binary combinations to a multistate character. As before, we may assume
that transitions in two states cannot occur at the same time and remove
the “dual” transitions.</p>
<p><span class="math display">\[
Q =
\begin{bmatrix}
-  &amp; q_{1 \rightarrow 2} &amp; q_{1 \rightarrow 3} &amp; -\\
q_{2 \rightarrow 1} &amp; - &amp; - &amp; q_{2 \rightarrow 4}\\
q_{3 \rightarrow 1} &amp; - &amp; - &amp; q_{3 \rightarrow 4}\\
- &amp; q_{4 \rightarrow 2} &amp; q_{4 \rightarrow 3} &amp; -\\
\end{bmatrix}
\]</span></p>
<p>Again, exactly the same.</p>
<p>The updated version of <code><a href="../reference/corHMM.html">corHMM()</a></code> now lets users transform
a set of characters into a <em>single</em> multistate character. This
means that two characters need not have the same number of character
states – that is, one trait could have four states, and the other could
be binary. We also allow any model to be expanded to accomodate an
arbitrary number of hidden states. Thus, <code><a href="../reference/corHMM.html">corHMM()</a></code> is
completely flexible and naturally contains <code><a href="../reference/rayDISC.html">rayDISC()</a></code> and
<code><a href="../reference/corDISC.html">corDISC()</a></code> capabilities - standalone functions in previous
versions of <code>corHMM</code> that may have been mistaken as different
“methods.” As this vignette will show, they are indeed nested within a
broader class of HMMs.</p>
<div class="section level2">
<h2 id="section-1-default-use-of-corhmm">Section 1: Default use of corHMM<a class="anchor" aria-label="anchor" href="#section-1-default-use-of-corhmm"></a>
</h2>
<div class="section level3">
<h3 id="no-hidden-rate-categories">1.1: No hidden rate categories<a class="anchor" aria-label="anchor" href="#no-hidden-rate-categories"></a>
</h3>
<p>To start, we’ll use the primate dataset from Pagel and Meade (2006)
that comes with <code>corHMM</code>:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1985</span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">require</a></span><span class="op">(</span><span class="va"><a href="http://ape-package.ird.fr/" class="external-link">ape</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">require</a></span><span class="op">(</span><span class="va"><a href="https://R-Forge.R-project.org/projects/expm/" class="external-link">expm</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">require</a></span><span class="op">(</span><span class="va">corHMM</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">primates</span><span class="op">)</span></span>
<span><span class="va">phy</span> <span class="op">&lt;-</span> <span class="va">primates</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">phy</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/multi2di.html" class="external-link">multi2di</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="va">primates</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span></span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">phy</span>, show.tip.label <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="va">data.sort</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">data</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>, <span class="va">data</span><span class="op">[</span>, <span class="fl">3</span><span class="op">]</span>, row.names <span class="op">=</span> <span class="va">data</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">data.sort</span> <span class="op">&lt;-</span> <span class="va">data.sort</span><span class="op">[</span><span class="va">phy</span><span class="op">$</span><span class="va">tip.label</span>, <span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ape/man/nodelabels.html" class="external-link">tiplabels</a></span><span class="op">(</span>pch <span class="op">=</span> <span class="fl">16</span>, col <span class="op">=</span> <span class="va">data.sort</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span>, cex <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ape/man/nodelabels.html" class="external-link">tiplabels</a></span><span class="op">(</span>pch <span class="op">=</span> <span class="fl">16</span>, col <span class="op">=</span> <span class="va">data.sort</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="fl">3</span>, cex <span class="op">=</span> <span class="fl">0.5</span>, offset <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="corHMMv2.1-vignette_files/figure-html/unnamed-chunk-2-1.png" width="576" style="display: block; margin: auto;"></p>
<p>We have two characters each with two possible states: trait 1 is the
absence (black) or presence (red) of estrus advertisement in females,
and trait 2 is single male (green) or multimale (blue) mating system in
primates.</p>
<p>The default use of <code><a href="../reference/corHMM.html">corHMM()</a></code> only requires that you
declare your <em>phylogeny</em>, your <em>dataset</em>, and the number
of <em>rate categories</em> (more detail about this later). We have
updated <code><a href="../reference/corHMM.html">corHMM()</a></code> to handle different types of input data.
Now to use <code><a href="../reference/corHMM.html">corHMM()</a></code>, the first column must be species names
(as in the previous version), but there can be any number of data
columns. If your dataset does have 2 or more columns of trait
information, each column is taken to describe a separate character. Note
that when the <code><a href="../reference/corHMM.html">corHMM()</a></code> call is used, the function
automatically determines all the unique character combinations
<em>observed</em> in the data set. In our primate example only 3 of the
4 possible combinations are observed, and so the model is constructed
accordingly. Also, dual transitions are automatically disallowed. In
other words, we expect that a species cannot go directly from estrus
advertisement being absent in a single male mating system to having
estrus advertisement in a multimale mating system. They must first
evolve either estrus advertisement or multimale mating system.</p>
<p>Let’s give this a try:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## MK_3state &lt;- corHMM(phy = phy, data = data, rate.cat = 1)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/load.html" class="external-link">load</a></span><span class="op">(</span><span class="st">"corHMMResults.Rsave"</span><span class="op">)</span></span>
<span><span class="va">MK_3state</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Fit</span></span>
<span><span class="co">##       -lnL      AIC     AICc Rate.cat ntax</span></span>
<span><span class="co">##  -41.90867 91.81735 92.54462        1   60</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Legend</span></span>
<span><span class="co">##     1     2     3 </span></span>
<span><span class="co">## "0_0" "0_1" "1_1" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Rates</span></span>
<span><span class="co">##            (1,R1)     (2,R1)     (3,R1)</span></span>
<span><span class="co">## (1,R1)         NA 0.01899834         NA</span></span>
<span><span class="co">## (2,R1) 0.05663462         NA 0.02627072</span></span>
<span><span class="co">## (3,R1)         NA 0.01610455         NA</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Arrived at a reliable solution</span></span></code></pre>
<p>When you run your <code>corHMM</code> object you are greeted with a
summary of the model. Your model fit is described by the log likelihood
(lnL), Akaike information criterion (AIC), and sample size corrected
Akaike information criterion (AICc). You are also given the number of
rate categories (Rate.cat) and number of taxa (ntax).</p>
<p>The <em>Rates</em> section of the output describes transition rates
between states and are organized as a matrix. Again, the <em>transition
rate matrix</em> is read as the transition rate <strong>from</strong>
ROW <strong>to</strong> COLUMN. For example, if you were interested in
the transition rate from State 1 (i.e., absence of estrus advertisement
in a single male mating system) to State 2 (i.e., absence of estrus
advertisement in a multimale mating system) you would be looking at the
Row 1, Column 2, entry. For a time calibrated ultrametric tree, these
rates will depend on the age of your phylogeny.</p>
<p>You may also notice that <code><a href="../reference/corHMM.html">corHMM()</a></code> printed a state legend
to the screen. Thus, you can obtain the exact coding for each species in
an augmented dataframe provided by the <code><a href="../reference/corHMM.html">corHMM()</a></code> results
object itself. This dataframe uses the initial user data to create
columns that corresponds to how each species was represented in
<code><a href="../reference/corHMM.html">corHMM()</a></code>:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">MK_3state</span><span class="op">$</span><span class="va">data.legend</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                        sp d</span></span>
<span><span class="co">## 1    Cercocebus_torquatus 3</span></span>
<span><span class="co">## 2  Cercopithecus_aethiops 2</span></span>
<span><span class="co">## 3      Cercopithecus_mona 1</span></span>
<span><span class="co">## 4 Cercopithecus_nictitans 1</span></span>
<span><span class="co">## 5      Colobus_angolensis 2</span></span>
<span><span class="co">## 6         Colobus_guereza 1</span></span></code></pre>
<p>Alternatively, a user can supply their dataset to getStateMat4Dat,
which outputs a legend that is consistent with the <code><a href="../reference/corHMM.html">corHMM()</a></code>
function. The other output is an index matrix (or rate matrix) that
describes which rates are to be estimated in <code><a href="../reference/corHMM.html">corHMM()</a></code>. We
provide an in-depth discussion about this part of the index matrix
later:</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/getRateMat4Dat.html">getStateMat4Dat</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## $legend</span></span>
<span><span class="co">##     1     2     3 </span></span>
<span><span class="co">## "0_0" "0_1" "1_1" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $rate.mat</span></span>
<span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)   0   2   0</span></span>
<span><span class="co">## (2)   1   0   4</span></span>
<span><span class="co">## (3)   0   3   0</span></span></code></pre>
<p>Finally, interpreting a Markov matrix can be difficult, especially
when you’re just starting out. This problem is compounded when users
begin to apply the more complex hidden Markov models (i.e. setting
rate.cat &gt; 1). To help users, we have implemented a new plotting
function:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plotMKmodel.html">plotMKmodel</a></span><span class="op">(</span><span class="va">MK_3state</span><span class="op">)</span></span></code></pre></div>
<p><img src="corHMMv2.1-vignette_files/figure-html/unnamed-chunk-6-1.png" width="576" style="display: block; margin: auto;"></p>
<p>This function uses a <code>corHMM</code> object (which is the result
of running <code><a href="../reference/corHMM.html">corHMM()</a></code>) or a custom rate matrix (discussed in
a later section) to plot the model in two parts. On the left is a ball
and stick diagram that depicts the state transitions. On the right is a
simplified rate matrix that contains rounded values from the solution
output of <code><a href="../reference/corHMM.html">corHMM()</a></code>. The colors of the arrows correspond to
the magnitude of the rates.</p>
<p>The final new plotting tool we have made available to users is a
stochastic character mapping function, <code>makeSimmap</code>
(Bollback, 2006). We can use <code>makeSimmap</code> to create a
character history for any <code>corHMM</code> model and then use
plotSimmap (from the popular R-package, <code>phytools</code>) to plot
the output.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">phy</span> <span class="op">=</span> <span class="va">MK_3state</span><span class="op">$</span><span class="va">phy</span></span>
<span><span class="va">data</span> <span class="op">=</span> <span class="va">MK_3state</span><span class="op">$</span><span class="va">data</span></span>
<span><span class="va">model</span> <span class="op">=</span> <span class="va">MK_3state</span><span class="op">$</span><span class="va">solution</span></span>
<span><span class="va">model</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="op">-</span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span></span>
<span><span class="co"># run get simmap (can be plotted using phytools)</span></span>
<span><span class="va">simmap</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/makeSimmap.html">makeSimmap</a></span><span class="op">(</span>tree <span class="op">=</span> <span class="va">phy</span>, data <span class="op">=</span> <span class="va">data</span>, model <span class="op">=</span> <span class="va">model</span>, rate.cat <span class="op">=</span> <span class="fl">1</span>, nSim <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    nCores <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="co"># we import phytools plotSimmap for plotting</span></span>
<span><span class="fu">phytools</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/phytools/man/plotSimmap.html" class="external-link">plotSimmap</a></span><span class="op">(</span><span class="va">simmap</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, fsize <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## no colors provided. using the following legend:</span></span>
<span><span class="co">##       0_0       0_1       1_1 </span></span>
<span><span class="co">##   "black" "#DF536B" "#61D04F"</span></span></code></pre>
<p><img src="corHMMv2.1-vignette_files/figure-html/unnamed-chunk-7-1.png" width="700"></p>
<div class="section level5">
<h5 id="a-trait-with-any-number-of-states-and-any-number-of-hidden-rate-categories">1.2: A trait with any number of states and any number of hidden rate
categories<a class="anchor" aria-label="anchor" href="#a-trait-with-any-number-of-states-and-any-number-of-hidden-rate-categories"></a>
</h5>
<p>The major difference between this version of <code>corHMM</code> and
previous versions is allowing models of any number of states and any
number of hidden rate categories (<em>hidden rate categories will be
explained in more depth in section 2</em>). Running a hidden Markov
model (HMM) only requires assigning a value greater than 1 to the
rate.cat input. Below, we have assigned 2 rate categories to the data
from above:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## HMM_3state &lt;- corHMM(phy = phy, data = data, rate.cat = 2, model = "SYM", get.tip.states = TRUE)</span></span>
<span><span class="va">HMM_3state</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Fit</span></span>
<span><span class="co">##       -lnL      AIC     AICc Rate.cat ntax</span></span>
<span><span class="co">##  -41.54993 95.09986 96.68477        2   60</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Legend</span></span>
<span><span class="co">##     1     2     3 </span></span>
<span><span class="co">## "0_0" "0_1" "1_1" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Rates</span></span>
<span><span class="co">##            (1,R1)     (2,R1)     (3,R1)      (1,R2)      (2,R2)     (3,R2)</span></span>
<span><span class="co">## (1,R1)         NA 8.98935353         NA 0.039272357          NA         NA</span></span>
<span><span class="co">## (2,R1) 8.98935353         NA 0.03045584          NA 0.039272357         NA</span></span>
<span><span class="co">## (3,R1)         NA 0.03045584         NA          NA          NA 0.03927236</span></span>
<span><span class="co">## (1,R2) 0.01746178         NA         NA          NA 0.000000001         NA</span></span>
<span><span class="co">## (2,R2)         NA 0.01746178         NA 0.000000001          NA 0.01176923</span></span>
<span><span class="co">## (3,R2)         NA         NA 0.01746178          NA 0.011769228         NA</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Arrived at a reliable solution</span></span></code></pre>
<p>Models with more states (larger state space) take longer to estimate
because the number of transition rates increases. Hidden rate models
further expand state space. For example, adding a second rate category
incerases the number of transition rates from 4 to 10 (if the model is
left as the default “ARD”). In section 1.1 we left our parameters
unconstrained. We estimated all transisions as independent and allowed
for transitions from all states to any other state. However, we can
constrain a model in <code>corHMM</code> in two different ways. The
easiest way is to set the model to either “SYM” or “ER”. This is what
we’ve done for the HMM_3state model above. By setting model = “SYM”, we
have forced the transition rates between any two states to be equal. In
comparison, model = “ER” constrains all transition rates between states
to be the same. Finally, model = “ARD” (the default) allows all
transition rates to be independently estimated. Although “ER” and “SYM
are common restrictions, it is often more useful to manually restrict
your model to match a biological hypothesis (which is described in the
next section). Finally, we set get.tip.states to be true because it is
necessary for simmaps.</p>
<p>Interpreting the estimated rate matrix for this hidden Markov model
is intimidating. But, the same principles of interpreting the transition
rate matrices apply – that is, you still read rates from row to column.
However, there is the added complexity of transitions among the
different rate categories (as represented by R1 and R2).
<code><a href="../reference/plotMKmodel.html">plotMKmodel()</a></code> will plot the underlying structure of model
in discrete parts. In the following example, the first 2 panels show how
observed states transition within each rate category, and the last panel
shows transitions among the different rate classes:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plotMKmodel.html">plotMKmodel</a></span><span class="op">(</span><span class="va">HMM_3state</span>, display <span class="op">=</span> <span class="st">"row"</span><span class="op">)</span></span></code></pre></div>
<p><img src="corHMMv2.1-vignette_files/figure-html/unnamed-chunk-9-1.png" width="960" style="display: block; margin: auto;"></p>
<p>And again we can plot the simmap of this <code>corHMM</code> result.
It is important to note that a character history not only generates
hypotheses about ancestral states, but is an effective way to visualize
the tempo of evolution. This is particularly important for HMMs where
rates of evolution can vary drastically across the tree.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># get simmap inputs from corhmm outputs</span></span>
<span><span class="va">phy</span> <span class="op">=</span> <span class="va">HMM_3state</span><span class="op">$</span><span class="va">phy</span></span>
<span><span class="va">data</span> <span class="op">=</span> <span class="va">HMM_3state</span><span class="op">$</span><span class="va">data</span></span>
<span><span class="va">model</span> <span class="op">=</span> <span class="va">HMM_3state</span><span class="op">$</span><span class="va">solution</span></span>
<span><span class="va">model</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/diag.html" class="external-link">diag</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="op">-</span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/colSums.html" class="external-link">rowSums</a></span><span class="op">(</span><span class="va">model</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># run get simmap (can be plotted using phytools)</span></span>
<span><span class="va">simmap</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/makeSimmap.html">makeSimmap</a></span><span class="op">(</span>tree <span class="op">=</span> <span class="va">phy</span>, data <span class="op">=</span> <span class="va">data</span>, model <span class="op">=</span> <span class="va">model</span>, rate.cat <span class="op">=</span> <span class="fl">2</span>, nSim <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    nCores <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># we import phytools plotSimmap for plotting</span></span>
<span><span class="fu">phytools</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/phytools/man/plotSimmap.html" class="external-link">plotSimmap</a></span><span class="op">(</span><span class="va">simmap</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span>, fsize <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## no colors provided. using the following legend:</span></span>
<span><span class="co">##  (0_0,R1)  (0_0,R2)  (0_1,R1)  (0_1,R2)  (1_1,R1)  (1_1,R2) </span></span>
<span><span class="co">##   "black" "#DF536B" "#61D04F" "#2297E6" "#28E2E5" "#CD0BBC"</span></span></code></pre>
<p><img src="corHMMv2.1-vignette_files/figure-html/unnamed-chunk-10-1.png" width="700"></p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="section-2-how-to-make-and-interpret-custom-models">Section 2: How to make and interpret custom models<a class="anchor" aria-label="anchor" href="#section-2-how-to-make-and-interpret-custom-models"></a>
</h2>
<div class="section level3">
<h3 id="creating-and-using-custom-rate-matrices">2.1: Creating and using custom rate matrices<a class="anchor" aria-label="anchor" href="#creating-and-using-custom-rate-matrices"></a>
</h3>
<div class="section level4">
<h4 id="one-rate-category">2.1.1: One rate category<a class="anchor" aria-label="anchor" href="#one-rate-category"></a>
</h4>
<p>At its core, the purpose of a rate matrix (i.e.,
<code>rate.mat</code>) is to indicate to <code>corHMM</code> which
parameters are being estimated. It specifies to <code><a href="../reference/corHMM.html">corHMM()</a></code>
which rates in the matrix are being estimated and if any of them are
expected to be identical.</p>
<p>A custom rate matrix allows you to specify explicit hypotheses. For
example, such an approach allows for tests of evolution of traits in a
particular order, tests of different rates of evolution in different
clades, or tests of the presence of hidden precursors before a state can
evolve.</p>
<p>Let’s start by using the <code><a href="../reference/getRateMat4Dat.html">getStateMat4Dat()</a></code> function to
get a generic <code>rate.mat</code> object:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">LegendAndRateMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getRateMat4Dat.html">getStateMat4Dat</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span></span>
<span><span class="va">RateMat</span> <span class="op">&lt;-</span> <span class="va">LegendAndRateMat</span><span class="op">$</span><span class="va">rate.mat</span></span>
<span><span class="va">RateMat</span></span></code></pre></div>
<pre><code><span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)   0   2   0</span></span>
<span><span class="co">## (2)   1   0   4</span></span>
<span><span class="co">## (3)   0   3   0</span></span></code></pre>
<p>The numbers in this matrix are not rates, they are used to index the
unique parameters to be estimated by <code><a href="../reference/corHMM.html">corHMM()</a></code>. Each
distinct number is a parameter to be estimated independently from all
others. Let’s manually create the symmetric model we used in secion 1.2.
In the symmetric model we want transitions <em>to</em> a state to be the
same as <em>from</em> that state. This means that (1) <span class="math inline">\(\rightarrow\)</span> (2) &amp; (2) <span class="math inline">\(\rightarrow\)</span> (1) are equal AND that (3)
<span class="math inline">\(\rightarrow\)</span>(2) and (2) <span class="math inline">\(\rightarrow\)</span> (3) are equal. In other
words, based on the <code>rate.mat</code> above, we want parameters 1
&amp; 2 to be equal and we want parameters 3 &amp; 4 to be equal as
shown below:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pars2equal</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">StateMatA_constrained</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">equateStateMatPars</a></span><span class="op">(</span><span class="va">RateMat</span>, <span class="va">pars2equal</span><span class="op">)</span></span>
<span><span class="va">StateMatA_constrained</span></span></code></pre></div>
<pre><code><span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)  NA   1  NA</span></span>
<span><span class="co">## (2)   1  NA   2</span></span>
<span><span class="co">## (3)  NA   2  NA</span></span></code></pre>
<p>To manually create a symmetric model, we used the
equateStateMatPars() function, in which the first argument is the rate
matrix being modified (i.e., rate.mat object) and second argument is
list of the parameters to be equated. One thing to note is that you must
have the appropriate number of rate categories since a user rate matrix
is not duplicated or changed by <code><a href="../reference/corHMM.html">corHMM()</a></code>. Thus, this custom
model can only be used if we set rate.cat=1 since that is the
appropriate number of rate categories. We can now provide this
customized <code>rate.mat</code> to <code><a href="../reference/corHMM.html">corHMM()</a></code>:</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## MK_3state_customSYM &lt;- corHMM(phy = phy, data = data, rate.cat = 1, rate.mat = StateMatA_constrained)</span></span>
<span><span class="va">MK_3state_customSYM</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Fit</span></span>
<span><span class="co">##       -lnL     AIC     AICc Rate.cat ntax</span></span>
<span><span class="co">##  -44.36715 92.7343 92.94482        1   60</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Legend</span></span>
<span><span class="co">##     1     2     3 </span></span>
<span><span class="co">## "0_0" "0_1" "1_1" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Rates</span></span>
<span><span class="co">##            (1,R1)     (2,R1)     (3,R1)</span></span>
<span><span class="co">## (1,R1)         NA 0.02569597         NA</span></span>
<span><span class="co">## (2,R1) 0.02569597         NA 0.01968806</span></span>
<span><span class="co">## (3,R1)         NA 0.01968806         NA</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Arrived at a reliable solution</span></span></code></pre>
</div>
<div class="section level4">
<h4 id="any-number-of-rate-categories">2.1.2: Any number of rate categories<a class="anchor" aria-label="anchor" href="#any-number-of-rate-categories"></a>
</h4>
<p>From a technical standpoint, hidden Markov models have a hierarchical
structure that can be broken down into two components: a
“state-dependent process” and an unobserved “parameter process”
(Zucchini et al. 2017). In comparative biology, the standard
“state-dependent process” model is a continuous-time Markov chain. The
observed states could be any discretized trait such as presence or
absence of extrafloral nectaries (Marazzi et al. 2012), woody or
herbaceous growth habit (Beaulieu et al. 2013), or diet state across all
animals (Roman-Palacios et al. 2019). However, a simple Markov process
alone that assumes homogeneity through time and across taxa is often not
adequate to capture the variation of real datasets (e.g. Beaulieu et
al. 2013). One option is to say that the observed data is the product of
several processes occurring in different parts of a phylogeny. The
parameter process describes how several state-dependent processes relate
to one another. Thus, observations are generated by a given
state-dependent process depending on the state of the parameter process.
It is initially unknown what the parameter process corresponds to
biologically, hence the moniker “hidden” state.</p>
<p>If you wanted to add hidden rate categories, you need to know: (1)
the dynamics <em>within</em> each rate category (state-dependent
processes), and (2) transitions <em>between</em> the different rate
classes (parameter process). We begin by constructing two
<em>within</em> rate category <code>rate.mat</code> objects (R1 and R2).
In R1, we assume a drift-like hypothesis where all transition rates are
equal. In R2, we assume that the combination of estrus advertisement and
multimale mating systems are not lost once they evolve:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">RateCat1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getRateMat4Dat.html">getStateMat4Dat</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">$</span><span class="va">rate.mat</span>  <span class="co"># R1</span></span>
<span><span class="va">RateCat1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">equateStateMatPars</a></span><span class="op">(</span><span class="va">RateCat1</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">RateCat1</span></span></code></pre></div>
<pre><code><span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)  NA   1  NA</span></span>
<span><span class="co">## (2)   1  NA   1</span></span>
<span><span class="co">## (3)  NA   1  NA</span></span></code></pre>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">RateCat2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getRateMat4Dat.html">getStateMat4Dat</a></span><span class="op">(</span><span class="va">data</span><span class="op">)</span><span class="op">$</span><span class="va">rate.mat</span>  <span class="co"># R2</span></span>
<span><span class="va">RateCat2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">dropStateMatPars</a></span><span class="op">(</span><span class="va">RateCat2</span>, <span class="fl">3</span><span class="op">)</span></span>
<span><span class="va">RateCat2</span></span></code></pre></div>
<pre><code><span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)  NA   2  NA</span></span>
<span><span class="co">## (2)   1  NA   3</span></span>
<span><span class="co">## (3)  NA  NA  NA</span></span></code></pre>
<p>With respect to transitions <em>among</em> the different rate
classes, we have implemented a separate matrix generator,
<code><a href="../reference/getFullMat.html">getRateCatMat()</a></code>. By default, this function will assume that
all transitions among the specified number of rate classes occur
independently. In our example, we will generate a matrix that specifies
how transitions between R1 and R2 occur. Note that R1 and R2 could
represent a biologically-relevant, but unmeasured factor, such as, say,
temperate or tropical environments, island or mainland, presence or
absence of a third trait. Basically, it is everything and anything that
can influence the evolution of your observed characters.</p>
<p>For illustrative purposes, we will specify that the transition rate
from R1 to R2 is the same as the rate from R2 to R1:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">RateClassMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">getRateCatMat</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>  <span class="co">#</span></span>
<span><span class="va">RateClassMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">equateStateMatPars</a></span><span class="op">(</span><span class="va">RateClassMat</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">RateClassMat</span></span></code></pre></div>
<pre><code><span><span class="co">##    R1 R2</span></span>
<span><span class="co">## R1 NA  1</span></span>
<span><span class="co">## R2  1 NA</span></span></code></pre>
<p>We now group all of our rate classes together in a list. The first
element of the list corresponds to R1, the second to R2, etc.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">StateMats</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">RateCat1</span>, <span class="va">RateCat2</span><span class="op">)</span></span>
<span><span class="va">StateMats</span></span></code></pre></div>
<pre><code><span><span class="co">## [[1]]</span></span>
<span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)  NA   1  NA</span></span>
<span><span class="co">## (2)   1  NA   1</span></span>
<span><span class="co">## (3)  NA   1  NA</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## [[2]]</span></span>
<span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)  NA   2  NA</span></span>
<span><span class="co">## (2)   1  NA   3</span></span>
<span><span class="co">## (3)  NA  NA  NA</span></span></code></pre>
<p>We now have all the components necessary to create the full model
using the <code><a href="../reference/getFullMat.html">getFullMat()</a></code> function. This function requires
that the first input be a list of the within rate class matrices and the
second argument be the among rate class matrices:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">FullMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">getFullMat</a></span><span class="op">(</span><span class="va">StateMats</span>, <span class="va">RateClassMat</span><span class="op">)</span></span>
<span><span class="va">FullMat</span></span></code></pre></div>
<pre><code><span><span class="co">##        (1,R1) (2,R1) (3,R1) (1,R2) (2,R2) (3,R2)</span></span>
<span><span class="co">## (1,R1)      0      1      0      5      0      0</span></span>
<span><span class="co">## (2,R1)      1      0      1      0      5      0</span></span>
<span><span class="co">## (3,R1)      0      1      0      0      0      5</span></span>
<span><span class="co">## (1,R2)      5      0      0      0      3      0</span></span>
<span><span class="co">## (2,R2)      0      5      0      2      0      4</span></span>
<span><span class="co">## (3,R2)      0      0      5      0      0      0</span></span></code></pre>
<p>Even though we created this larger index matrix from individuals
components, we may not be sure it’s exactly what we want. We can use
<code><a href="../reference/plotMKmodel.html">plotMKmodel()</a></code> to take a look at the model setup
<em>before</em> running the analysis. Here’s an example function
call:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plotMKmodel.html">plotMKmodel</a></span><span class="op">(</span><span class="va">FullMat</span>, rate.cat <span class="op">=</span> <span class="fl">2</span>, display <span class="op">=</span> <span class="st">"row"</span>, text.scale <span class="op">=</span> <span class="fl">0.7</span><span class="op">)</span></span></code></pre></div>
<p>Since this is the model we intended on making, we can run
<code><a href="../reference/corHMM.html">corHMM()</a></code> with our custom matrix:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## HMM_3state_custom &lt;- corHMM(phy = phy, data = data, rate.cat = 2, rate.mat = FullMat,</span></span>
<span><span class="co">##     node.states = "none")</span></span>
<span><span class="va">HMM_3state_custom</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Fit</span></span>
<span><span class="co">##       -lnL      AIC     AICc Rate.cat ntax</span></span>
<span><span class="co">##  -42.23859 94.47717 95.58828        2   60</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Legend</span></span>
<span><span class="co">##     1     2     3 </span></span>
<span><span class="co">## "0_0" "0_1" "1_1" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Rates</span></span>
<span><span class="co">##            (1,R1)     (2,R1)     (3,R1)     (1,R2)      (2,R2)     (3,R2)</span></span>
<span><span class="co">## (1,R1)         NA 4.93699136         NA 0.01009128          NA         NA</span></span>
<span><span class="co">## (2,R1) 4.93699136         NA 4.93699136         NA 0.010091278         NA</span></span>
<span><span class="co">## (3,R1)         NA 4.93699136         NA         NA          NA 0.01009128</span></span>
<span><span class="co">## (1,R2) 0.01009128         NA         NA         NA 0.009154181         NA</span></span>
<span><span class="co">## (2,R2)         NA 0.01009128         NA 0.04692934          NA 0.01252610</span></span>
<span><span class="co">## (3,R2)         NA         NA 0.01009128         NA          NA         NA</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Arrived at a reliable solution</span></span></code></pre>
<p>We may plot the resulting parameter estimates as before:</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plotMKmodel.html">plotMKmodel</a></span><span class="op">(</span><span class="va">HMM_3state_custom</span>, display <span class="op">=</span> <span class="st">"row"</span>, text.scale <span class="op">=</span> <span class="fl">0.7</span><span class="op">)</span></span></code></pre></div>
<p><img src="corHMMv2.1-vignette_files/figure-html/unnamed-chunk-20-1.png" width="960"></p>
</div>
</div>
<div class="section level3">
<h3 id="biological-examples">2.2: Biological examples<a class="anchor" aria-label="anchor" href="#biological-examples"></a>
</h3>
<div class="section level4">
<h4 id="ordered-habitat-change">2.2.1: Ordered habitat change<a class="anchor" aria-label="anchor" href="#ordered-habitat-change"></a>
</h4>
<p>A lot of these new capabilities in <code>corHMM</code> were inspired
by our current project examining the ancestral habitat during primary
endosymbiosis. In our model, we have three possible habitats: marine,
freshwater, and terrestrial. Our very large phylogeny of green plants
contains many species with a diverse range of life histories. For
example, cyanobacteria can move freely between all of these states,
whereas some species may move between terrestrial and marine through
freshwater. Some species may even move freely between aquatic states,
but once they become terrestrial they are stuck there. In this section
we will demonstrate how to create a custom hidden Markov model which
satisfies all of these requirements.</p>
<p>To do this we will use a simulated a dataset that contains these 3
states:</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">phy</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/read.tree.html" class="external-link">read.tree</a></span><span class="op">(</span><span class="st">"randomBD.tree"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/load.html" class="external-link">load</a></span><span class="op">(</span><span class="st">"simulatedData.Rsave"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">MFT_dat</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##    sp           d</span></span>
<span><span class="co">## 1  s7  Freshwater</span></span>
<span><span class="co">## 2 s14      Marine</span></span>
<span><span class="co">## 3 s16      Marine</span></span>
<span><span class="co">## 4 s17 Terrestrial</span></span>
<span><span class="co">## 5 s18 Terrestrial</span></span>
<span><span class="co">## 6 s21      Marine</span></span></code></pre>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/factor.html" class="external-link">as.factor</a></span><span class="op">(</span><span class="va">MFT_dat</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>  <span class="co"># how many of each state do we have?</span></span></code></pre></div>
<pre><code><span><span class="co">##  Freshwater      Marine Terrestrial </span></span>
<span><span class="co">##           7          14          79</span></span></code></pre>
<p>As before, start off by getting a legend and rate matrix from this
dataset:</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">MFT_LegendAndRate</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getRateMat4Dat.html">getStateMat4Dat</a></span><span class="op">(</span><span class="va">MFT_dat</span><span class="op">)</span></span>
<span><span class="va">MFT_LegendAndRate</span></span></code></pre></div>
<pre><code><span><span class="co">## $legend</span></span>
<span><span class="co">##             1             2             3 </span></span>
<span><span class="co">##  "Freshwater"      "Marine" "Terrestrial" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $rate.mat</span></span>
<span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)   0   3   5</span></span>
<span><span class="co">## (2)   1   0   6</span></span>
<span><span class="co">## (3)   2   4   0</span></span></code></pre>
<p>Here, freshwater habitat will be State 1, marine habitat will be
State 2,and terrestrial habitat will be State 3. Now, we need to create
3 different rate classes that are consistent with our hypotheses of how
habitat changes occurs. We’ll say that rate class R1 is one in which
lineages cannot leave a terrestrial habitat, rate class R2 will allow
linneages to transition between marine and terrestrial <em>only</em>
through freshwater, and rate class R3 will be unrestricted movement
between the habitats.</p>
<p>For R1 we need terrestrial to be an absorbing state, meaning once
terrestriality evolves it is not lost. Since 1 = freshwater, 2 = marine,
and 3 = terrestrial, that means removing from (3) to (1) and from (3) to
(2).</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">MFT_R1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">dropStateMatPars</a></span><span class="op">(</span><span class="va">MFT_LegendAndRate</span><span class="op">$</span><span class="va">rate.mat</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">MFT_R1</span></span></code></pre></div>
<pre><code><span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)  NA   2   3</span></span>
<span><span class="co">## (2)   1  NA   4</span></span>
<span><span class="co">## (3)  NA  NA  NA</span></span></code></pre>
<p>For R2, we need to disallow transitions between terrestrial and
marine. We disallow the positions (1,3) and (3,1) in the rate matrix. In
this case, any lineage can move into freshwater and move out of
freshwater, but they are not allowed to transition directly between
terrestrial and marine habitats:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">MFT_R2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">dropStateMatPars</a></span><span class="op">(</span><span class="va">MFT_LegendAndRate</span><span class="op">$</span><span class="va">rate.mat</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">6</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">MFT_R2</span></span></code></pre></div>
<pre><code><span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)  NA   3   4</span></span>
<span><span class="co">## (2)   1  NA  NA</span></span>
<span><span class="co">## (3)   2  NA  NA</span></span></code></pre>
<p>For R3, we allow all possible transitions to occur, which is the
default matrix provided by getStateMat4Dat:</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">MFT_R3</span> <span class="op">&lt;-</span> <span class="va">MFT_LegendAndRate</span><span class="op">$</span><span class="va">rate.mat</span></span>
<span><span class="va">MFT_R3</span></span></code></pre></div>
<pre><code><span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)   0   3   5</span></span>
<span><span class="co">## (2)   1   0   6</span></span>
<span><span class="co">## (3)   2   4   0</span></span></code></pre>
<p>Let’s put all these matrices in a list,</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">MFT_ObsStateClasses</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">MFT_R1</span>, <span class="va">MFT_R2</span>, <span class="va">MFT_R3</span><span class="op">)</span></span></code></pre></div>
<p>Since we only have 100 species in this example, let’s constrain our
parameters a bit further and state that transitions between rate classes
occur at the same rate:</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">MFT_RateClassMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">getRateCatMat</a></span><span class="op">(</span><span class="fl">3</span><span class="op">)</span>  <span class="co"># we have 3 rate classes</span></span>
<span><span class="va">MFT_RateClassMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">equateStateMatPars</a></span><span class="op">(</span><span class="va">MFT_RateClassMat</span>, <span class="fl">1</span><span class="op">:</span><span class="fl">6</span><span class="op">)</span></span></code></pre></div>
<p>Next, we put it all together into a corHMM compatible rate.mat:</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">MFT_FullMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">getFullMat</a></span><span class="op">(</span><span class="va">MFT_ObsStateClasses</span>, <span class="va">MFT_RateClassMat</span><span class="op">)</span></span>
<span><span class="va">MFT_FullMat</span></span></code></pre></div>
<pre><code><span><span class="co">##        (1,R1) (2,R1) (3,R1) (1,R2) (2,R2) (3,R2) (1,R3) (2,R3) (3,R3)</span></span>
<span><span class="co">## (1,R1)      0      2      3     15      0      0     15      0      0</span></span>
<span><span class="co">## (2,R1)      1      0      4      0     15      0      0     15      0</span></span>
<span><span class="co">## (3,R1)      0      0      0      0      0     15      0      0     15</span></span>
<span><span class="co">## (1,R2)     15      0      0      0      7      8     15      0      0</span></span>
<span><span class="co">## (2,R2)      0     15      0      5      0      0      0     15      0</span></span>
<span><span class="co">## (3,R2)      0      0     15      6      0      0      0      0     15</span></span>
<span><span class="co">## (1,R3)     15      0      0     15      0      0      0     11     13</span></span>
<span><span class="co">## (2,R3)      0     15      0      0     15      0      9      0     14</span></span>
<span><span class="co">## (3,R3)      0      0     15      0      0     15     10     12      0</span></span></code></pre>
<p>That’s kind of difficult to interpret, so be sure to plot it out
using <code><a href="../reference/plotMKmodel.html">plotMKmodel()</a></code></p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plotMKmodel.html">plotMKmodel</a></span><span class="op">(</span><span class="va">MFT_FullMat</span>, rate.cat <span class="op">=</span> <span class="fl">3</span>, display <span class="op">=</span> <span class="st">"square"</span>, text.scale <span class="op">=</span> <span class="fl">0.9</span><span class="op">)</span></span></code></pre></div>
<p>To run this model, we would only need to specify 1) the data, 2) the
phylogeny, 3) this matrix, and 4) that this matrix has 3 rate
categories:</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## MFT_res.corHMM &lt;- corHMM(phy = phy, data = MFT_dat, rate.cat = 3, rate.mat = MFT_FullMat,</span></span>
<span><span class="co">##     node.states = "none", root.p = "maddfitz")</span></span>
<span><span class="va">MFT_res.corHMM</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Fit</span></span>
<span><span class="co">##       -lnL      AIC    AICc Rate.cat ntax</span></span>
<span><span class="co">##  -56.60587 143.2117 148.926        3  100</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Legend</span></span>
<span><span class="co">##             1             2             3 </span></span>
<span><span class="co">##  "Freshwater"      "Marine" "Terrestrial" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Rates</span></span>
<span><span class="co">##             (1,R1)      (2,R1)       (3,R1)      (1,R2)    (2,R2)      (3,R2)</span></span>
<span><span class="co">## (1,R1)          NA 0.000000001  0.000000001 4.857902197        NA          NA</span></span>
<span><span class="co">## (2,R1) 0.000000001          NA 14.208891381          NA  4.857902          NA</span></span>
<span><span class="co">## (3,R1)          NA          NA           NA          NA        NA 4.857902197</span></span>
<span><span class="co">## (1,R2) 4.857902197          NA           NA          NA 84.755563 0.000000001</span></span>
<span><span class="co">## (2,R2)          NA 4.857902197           NA 0.000000001        NA          NA</span></span>
<span><span class="co">## (3,R2)          NA          NA  4.857902197 0.000000001        NA          NA</span></span>
<span><span class="co">## (1,R3) 4.857902197          NA           NA 4.857902197        NA          NA</span></span>
<span><span class="co">## (2,R3)          NA 4.857902197           NA          NA  4.857902          NA</span></span>
<span><span class="co">## (3,R3)          NA          NA  4.857902197          NA        NA 4.857902197</span></span>
<span><span class="co">##           (1,R3)    (2,R3)      (3,R3)</span></span>
<span><span class="co">## (1,R1) 4.8579022        NA          NA</span></span>
<span><span class="co">## (2,R1)        NA 4.8579022          NA</span></span>
<span><span class="co">## (3,R1)        NA        NA 4.857902197</span></span>
<span><span class="co">## (1,R2) 4.8579022        NA          NA</span></span>
<span><span class="co">## (2,R2)        NA 4.8579022          NA</span></span>
<span><span class="co">## (3,R2)        NA        NA 4.857902197</span></span>
<span><span class="co">## (1,R3)        NA 0.5280562 0.000000001</span></span>
<span><span class="co">## (2,R3) 0.4711517        NA 0.000000001</span></span>
<span><span class="co">## (3,R3) 1.2064486 0.2364842          NA</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Arrived at a reliable solution</span></span></code></pre>
</div>
<div class="section level4">
<h4 id="the-precursor-model">2.2.2: The precursor model<a class="anchor" aria-label="anchor" href="#the-precursor-model"></a>
</h4>
<p>The precursor model of Marazzi et al. (2012) marks the beginning of
HMMs being used in a phylogenetic comparative context. Marazzi et
al. (2012) were interested in locating putative evolutionary precursors
of plant extrafloral nectaries (EFNs). Specifically, there were 2
states, presence (1) or absence (0) of EFNs, but that only species with
an unobserved, hidden “precursor” trait could gain EFNs. Here we show
how you could design the canonical precursor model in
<code>corHMM</code> using custom rate matrices.</p>
<p>We will start by loading a simulated dataset of presence and absence
of extrafloral nectaries a randomly generated birth-death tree:</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">Precur_Dat</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##      sp d</span></span>
<span><span class="co">## s7   s7 0</span></span>
<span><span class="co">## s14 s14 0</span></span>
<span><span class="co">## s16 s16 0</span></span>
<span><span class="co">## s17 s17 0</span></span>
<span><span class="co">## s18 s18 1</span></span>
<span><span class="co">## s21 s21 0</span></span></code></pre>
<p>Next, generate an observed states only matrix using the input single
binary trait data set:</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Precur_LegendAndMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getRateMat4Dat.html">getStateMat4Dat</a></span><span class="op">(</span><span class="va">Precur_Dat</span><span class="op">)</span></span>
<span><span class="va">Precur_LegendAndMat</span></span></code></pre></div>
<pre><code><span><span class="co">## $legend</span></span>
<span><span class="co">##   1   2 </span></span>
<span><span class="co">## "0" "1" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $rate.mat</span></span>
<span><span class="co">##     (1) (2)</span></span>
<span><span class="co">## (1)   0   2</span></span>
<span><span class="co">## (2)   1   0</span></span></code></pre>
<p>Based on the legend, the absence of EFNs will be State 1 and the
presence of EFNs will be State 2. For a precursor model the transitions
between the two observed states, 1 and 2, are modulated by a third,
hidden trait, which we will call a precursor. The precursor is
represented by being in State 1 (lacking EFNs), but being in the
“precursor rate class” (R2 in this case). In other words, if we observe
that a species lacks EFN’s, we do not know if they also have the
precursor (i.e., 1,R2) or not (i.e., 1,R1). We do know, however, that
under a precursor model that if we observe EFN, they must always also
have the precursor trait, and so the presence of EFNs is always (2,R2).
So, we will use rate class R2 as a direct measurement of transitioning
between presence and absence of EFNs.</p>
<p>The first rate class, R1, will represent character changes in the
absence of the precursor, which is not possible without first gaining
the “precursor”. So, we will generate the default matrix, then drop all
possible transitions from this matrix:</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Precur_R1</span> <span class="op">&lt;-</span> <span class="va">Precur_LegendAndMat</span><span class="op">$</span><span class="va">rate.mat</span></span>
<span><span class="va">Precur_R1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">dropStateMatPars</a></span><span class="op">(</span><span class="va">Precur_R1</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">Precur_R1</span></span></code></pre></div>
<pre><code><span><span class="co">##     (1) (2)</span></span>
<span><span class="co">## (1)  NA  NA</span></span>
<span><span class="co">## (2)  NA  NA</span></span></code></pre>
<p>The second rate class, R2, will represent how our character changes
in the presence of the precursor. In this rate class, we expect that
species can either gain or lose EFNs at the same rate:</p>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Precur_R2</span> <span class="op">&lt;-</span> <span class="va">Precur_LegendAndMat</span><span class="op">$</span><span class="va">rate.mat</span></span>
<span><span class="va">Precur_R2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">equateStateMatPars</a></span><span class="op">(</span><span class="va">Precur_R2</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">Precur_R2</span></span></code></pre></div>
<pre><code><span><span class="co">##     (1) (2)</span></span>
<span><span class="co">## (1)  NA   1</span></span>
<span><span class="co">## (2)   1  NA</span></span></code></pre>
<p>Finally, we set up a matrix for that governs the transitions
<em>among</em> the rate classes:</p>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">RateClassMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">getRateCatMat</a></span><span class="op">(</span><span class="fl">2</span><span class="op">)</span>  <span class="co">#</span></span>
<span><span class="va">RateClassMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">equateStateMatPars</a></span><span class="op">(</span><span class="va">RateClassMat</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">RateClassMat</span></span></code></pre></div>
<pre><code><span><span class="co">##    R1 R2</span></span>
<span><span class="co">## R1 NA  1</span></span>
<span><span class="co">## R2  1 NA</span></span></code></pre>
<p>Putting them rate classes together we almost get the right model, but
we need to remove one extra transition rate between that connects rate
class R1 and R2 in the presence of EFNs, because, again, the precursor
model assumes that EFNs can <em>only</em> be gained in rate class 1.</p>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Precur_FullMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getFullMat.html">getFullMat</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="va">Precur_R1</span>, <span class="va">Precur_R2</span><span class="op">)</span>, <span class="va">RateClassMat</span><span class="op">)</span></span>
<span><span class="va">Precur_FullMat</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">2</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">4</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">0</span></span>
<span><span class="va">Precur_FullMat</span></span></code></pre></div>
<pre><code><span><span class="co">##        (1,R1) (2,R1) (1,R2) (2,R2)</span></span>
<span><span class="co">## (1,R1)      0      0      2      0</span></span>
<span><span class="co">## (2,R1)      0      0      0      0</span></span>
<span><span class="co">## (1,R2)      2      0      0      1</span></span>
<span><span class="co">## (2,R2)      0      0      1      0</span></span></code></pre>
<p>We now run <code><a href="../reference/corHMM.html">corHMM()</a></code> making sure to specify that we have
2 rate categories (or rate classes or hidden states - it’s all the
same).</p>
<div class="sourceCode" id="cb68"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Precur_res.corHMM</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/corHMM.html">corHMM</a></span><span class="op">(</span>phy <span class="op">=</span> <span class="va">phy</span>, data <span class="op">=</span> <span class="va">Precur_Dat</span>, rate.cat <span class="op">=</span> <span class="fl">2</span>, rate.mat <span class="op">=</span> <span class="va">Precur_FullMat</span>,</span>
<span>    root.p <span class="op">=</span> <span class="st">"maddfitz"</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## State distribution in data:</span></span>
<span><span class="co">## States:  1   2   </span></span>
<span><span class="co">## Counts:  57  43  </span></span>
<span><span class="co">## Beginning thorough optimization search -- performing 0 random restarts </span></span>
<span><span class="co">## Finished. Inferring ancestral states using marginal reconstruction.</span></span></code></pre>
<pre><code><span><span class="co">## Warning in getInfoPerNode(obj$lik.anc.states, Q): NaNs produced</span></span></code></pre>
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Precur_res.corHMM</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Fit</span></span>
<span><span class="co">##      -lnL      AIC     AICc Rate.cat ntax</span></span>
<span><span class="co">##  -63.3243 130.6486 130.7723        2  100</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Legend</span></span>
<span><span class="co">##   1   2 </span></span>
<span><span class="co">## "0" "1" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Rates</span></span>
<span><span class="co">##        (1,R1) (2,R1)      (1,R2)   (2,R2)</span></span>
<span><span class="co">## (1,R1)     NA     NA 0.000000001       NA</span></span>
<span><span class="co">## (2,R1)     NA     NA          NA       NA</span></span>
<span><span class="co">## (1,R2)  1e-09     NA          NA 1.562531</span></span>
<span><span class="co">## (2,R2)     NA     NA 1.562531494       NA</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Arrived at a reliable solution</span></span></code></pre>
</div>
<div class="section level4">
<h4 id="ontological-relationship-of-multiple-characters">2.2.3: Ontological relationship of multiple characters<a class="anchor" aria-label="anchor" href="#ontological-relationship-of-multiple-characters"></a>
</h4>
<p>Lets say we had a dataset with multiple characters: 1) presence or
absence of limbs, 2) presence or absence of fingers, 3) corporeal or
incorporeal form. It could look something like this:</p>
<div class="sourceCode" id="cb73"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">primates</span><span class="op">)</span></span>
<span><span class="va">phy</span> <span class="op">&lt;-</span> <span class="va">primates</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">phy</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/multi2di.html" class="external-link">multi2di</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="va">primates</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">Limbs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Limbs"</span>, <span class="st">"noLimbs"</span><span class="op">)</span><span class="op">[</span><span class="va">data</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span> <span class="op">+</span> <span class="fl">1</span><span class="op">]</span></span>
<span><span class="va">Fings</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">vector</a></span><span class="op">(</span><span class="st">"numeric"</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">phy</span><span class="op">$</span><span class="va">tip.label</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">Fings</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="va">Limbs</span> <span class="op">==</span> <span class="st">"Limbs"</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/which.html" class="external-link">which</a></span><span class="op">(</span><span class="va">Limbs</span> <span class="op">==</span> <span class="st">"Limbs"</span><span class="op">)</span><span class="op">)</span>,</span>
<span>    <span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">Corpo</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="st">"corporeal"</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">phy</span><span class="op">$</span><span class="va">tip.label</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">Ont_Dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>sp <span class="op">=</span> <span class="va">phy</span><span class="op">$</span><span class="va">tip.label</span>, limbs <span class="op">=</span> <span class="va">Limbs</span>, fings <span class="op">=</span> <span class="va">Fings</span>, corp <span class="op">=</span> <span class="va">Corpo</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">Ont_Dat</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##                      sp   limbs fings      corp</span></span>
<span><span class="co">## 1          Homo_sapiens noLimbs     0 corporeal</span></span>
<span><span class="co">## 2          Pan_paniscus   Limbs     1 corporeal</span></span>
<span><span class="co">## 3       Pan_troglodytes   Limbs     0 corporeal</span></span>
<span><span class="co">## 4       Gorilla_gorilla   Limbs     1 corporeal</span></span>
<span><span class="co">## 5        Pongo_pygmaeus   Limbs     0 corporeal</span></span>
<span><span class="co">## 6 Pongo_pygmaeus_abelii   Limbs     0 corporeal</span></span></code></pre>
<p>Previously, the user would have had to convert this dataset into a
format that could be read by the <code><a href="../reference/rayDISC.html">rayDISC()</a></code> function. This
task previously involved taking all possible unique combinations and
creating a multistate character, but this version of
<code><a href="../reference/corHMM.html">corHMM()</a></code> will internally do this for you:</p>
<div class="sourceCode" id="cb75"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">Ont_LegendAndMat</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/getRateMat4Dat.html">getStateMat4Dat</a></span><span class="op">(</span><span class="va">Ont_Dat</span><span class="op">)</span></span>
<span><span class="va">Ont_LegendAndMat</span></span></code></pre></div>
<pre><code><span><span class="co">## $legend</span></span>
<span><span class="co">##                     1                     2                     3 </span></span>
<span><span class="co">##   "Limbs_0_corporeal"   "Limbs_1_corporeal" "noLimbs_0_corporeal" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $rate.mat</span></span>
<span><span class="co">##     (1) (2) (3)</span></span>
<span><span class="co">## (1)   0   3   4</span></span>
<span><span class="co">## (2)   1   0   0</span></span>
<span><span class="co">## (3)   2   0   0</span></span></code></pre>
<p>Even though there were 3 binary characters (meaning 8 possible
states), only 3 combinations were actually observed. This is because all
of the species were corporeal and thus the incorporeal form didn’t
factor into the matrix structure. The next thing to notice is that one
of the potential states (No Limbs, Yes Fingers) is not present in the
dataset and thus not included in the model. In addition, the transition
from 3 (No Limbs, No Fingers) to 2 (Yes Limbs, Yes Fingers) is not
allowed because it is impossible to have fingers without having limbs.
Finally, all dual transitions have been removed.</p>
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">## Ont_res.corHMM &lt;- corHMM(phy = phy, data = Ont_Dat, rate.cat = 1, rate.mat = Ont_LegendAndMat$rate.mat,</span></span>
<span><span class="co">##     node.states = "none")</span></span></code></pre></div>
<p>Note that hidden states can be added to this model by following the
examples above.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="section-3-estimating-models-when-node-states-are-fixed">Section 3: Estimating models when node states are fixed<a class="anchor" aria-label="anchor" href="#section-3-estimating-models-when-node-states-are-fixed"></a>
</h2>
<div class="section level3">
<h3 id="fixing-a-single-node">3.1: Fixing a single node<a class="anchor" aria-label="anchor" href="#fixing-a-single-node"></a>
</h3>
<p>We also added the ability to fix any or all nodes in the input
phylogeny while estimating a model. This new feature was inspired by a
request from Scott Edwards, who was interested in whether the range of
rates of flight gain and loss will result in the highest probability of
a volant ancestor to flightless lineages. He ran a series of ancestral
state reconstructions under a range of rates of gain and loss of flight.
These ancestral state reconstructions focused on a single ancestor at a
time (since each ancestor will have a slightly different set of
parameters) and recorded the probability of a volant ancestor. These
analyses are included in the supplemental of Sackton et al. (2019).</p>
<p>In this updated version of <code>corHMM</code>, a user can fix
anywhere from a single node in a tree to an entire reconstruction from,
say parsimony, and estimate the transitions rate. One can even obtain
the likelihood of a reconstruction based on a fixed set of rates. To
demonstrate, let’s start by running a simple analysis of a binary
character, but fixing the state of a single node in the the primate
tree. Specifically, we are going to fix the most recent common ancestor
(MRCA) of Gorilla gorilla and Homo sapiens as exhibiting estrus
advertisement (i.e., State 1). The first step is to determine the the
indices for each state:</p>
<div class="sourceCode" id="cb78"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/data.html" class="external-link">data</a></span><span class="op">(</span><span class="va">primates</span><span class="op">)</span></span>
<span><span class="va">phy</span> <span class="op">&lt;-</span> <span class="va">primates</span><span class="op">[[</span><span class="fl">1</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="va">phy</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/multi2di.html" class="external-link">multi2di</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span></span>
<span><span class="va">data</span> <span class="op">&lt;-</span> <span class="va">primates</span><span class="op">[[</span><span class="fl">2</span><span class="op">]</span><span class="op">]</span></span>
<span><span class="fu"><a href="../reference/getRateMat4Dat.html">getStateMat4Dat</a></span><span class="op">(</span><span class="va">data</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## $legend</span></span>
<span><span class="co">##   1   2 </span></span>
<span><span class="co">## "0" "1" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## $rate.mat</span></span>
<span><span class="co">##     (1) (2)</span></span>
<span><span class="co">## (1)   0   2</span></span>
<span><span class="co">## (2)   1   0</span></span></code></pre>
<p>Here, index 2 represents the presence of estrus advertisement in the
model. The next step is to create a vector of node states. We start by
generating a string of <code>NA</code> of length equal to the number of
nodes plus the number of tips in the tree. The <code>NA</code> simply
tells <code><a href="../reference/corHMM.html">corHMM()</a></code> to ignore as these are nodes that are not
fixed. We then have to determine which node is the MRCA of <em>Gorilla
gorilla</em> and <em>Homo sapiens</em>:</p>
<div class="sourceCode" id="cb80"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">label.vector</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="fu"><a href="https://rdrr.io/pkg/ape/man/summary.phylo.html" class="external-link">Ntip</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/summary.phylo.html" class="external-link">Nnode</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">homo_gorilla</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/mrca.html" class="external-link">getMRCA</a></span><span class="op">(</span><span class="va">phy</span>, tip <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Homo_sapiens"</span>, <span class="st">"Gorilla_gorilla"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">homo_gorilla</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 64</span></span></code></pre>
<p>The node number should be 64. To set the state of the node, simply
replace the <code>NA</code> with the state of interest in the
<code>label.vector</code>, in this case with a <code>2</code>, in the
64th element. To set the node labels, we will clip off the first 60
elements, as these represent the states of the tips, which we set
differently:</p>
<div class="sourceCode" id="cb82"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">label.vector</span><span class="op">[</span><span class="va">homo_gorilla</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">phy</span><span class="op">$</span><span class="va">node.label</span> <span class="op">&lt;-</span> <span class="va">label.vector</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/pkg/ape/man/summary.phylo.html" class="external-link">Ntip</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<p>Plotting the tree allows users to visually check whether the right
node was fixed:</p>
<div class="sourceCode" id="cb83"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">phy</span>, cex <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ape/man/nodelabels.html" class="external-link">nodelabels</a></span><span class="op">(</span><span class="va">phy</span><span class="op">$</span><span class="va">node.label</span><span class="op">)</span></span></code></pre></div>
<p><img src="corHMMv2.1-vignette_files/figure-html/unnamed-chunk-44-1.png" width="576" style="display: block; margin: auto;"></p>
<p>From here simply input the <code>tree</code> object in
<code><a href="../reference/corHMM.html">corHMM()</a></code> as normal, but the option fix.nodes needs to be
set to <code>TRUE</code>:</p>
<pre><code><span><span class="co">## Warning in corHMM(phy, data[, c(1, 2)], model = "ER", rate.cat = 1, fixed.nodes</span></span>
<span><span class="co">## = TRUE): Branch lengths of 0 detected. Adding 1e-5 to these branches.</span></span></code></pre>
<pre><code><span><span class="co">## State distribution in data:</span></span>
<span><span class="co">## States:  1   2   </span></span>
<span><span class="co">## Counts:  39  21  </span></span>
<span><span class="co">## Beginning thorough optimization search -- performing 0 random restarts </span></span>
<span><span class="co">## Finished. Inferring ancestral states using marginal reconstruction.</span></span></code></pre>
<p>We can then compare the fit of this model with another model where
the same node is fixed to lacking estrus advertisement:</p>
<div class="sourceCode" id="cb86"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">label.vector</span><span class="op">[</span><span class="va">homo_gorilla</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span><span class="va">phy</span><span class="op">$</span><span class="va">node.label</span> <span class="op">&lt;-</span> <span class="va">label.vector</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/pkg/ape/man/summary.phylo.html" class="external-link">Ntip</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="va">fix.node64.noestrus</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/corHMM.html">corHMM</a></span><span class="op">(</span><span class="va">phy</span>, <span class="va">data</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">]</span>, model <span class="op">=</span> <span class="st">"ER"</span>, rate.cat <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    fixed.nodes <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in corHMM(phy, data[, c(1, 2)], model = "ER", rate.cat = 1, fixed.nodes</span></span>
<span><span class="co">## = TRUE): Branch lengths of 0 detected. Adding 1e-5 to these branches.</span></span></code></pre>
<pre><code><span><span class="co">## State distribution in data:</span></span>
<span><span class="co">## States:  1   2   </span></span>
<span><span class="co">## Counts:  39  21  </span></span>
<span><span class="co">## Beginning thorough optimization search -- performing 0 random restarts </span></span>
<span><span class="co">## Finished. Inferring ancestral states using marginal reconstruction.</span></span></code></pre>
<div class="sourceCode" id="cb89"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fix.node64.noestrus</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Fit</span></span>
<span><span class="co">##       -lnL      AIC     AICc Rate.cat ntax</span></span>
<span><span class="co">##  -22.22758 46.45517 46.52413        1   60</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Legend</span></span>
<span><span class="co">##   1   2 </span></span>
<span><span class="co">## "0" "1" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Rates</span></span>
<span><span class="co">##             (1,R1)      (2,R1)</span></span>
<span><span class="co">## (1,R1)          NA 0.008338391</span></span>
<span><span class="co">## (2,R1) 0.008338391          NA</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Arrived at a reliable solution</span></span></code></pre>
<p>This comparison shows that the model where the MRCA of Gorilla
gorilla and Homo sapiens is assumed to have exhibited estrus
advertisement requires higher rates, and produces a substantially worse
likelihood, than the model that assumes the MRCA lacked estrus
advertisement.</p>
</div>
<div class="section level3">
<h3 id="estimating-rates-under-a-parsimony-reconstruction">3.2: Estimating rates under a parsimony reconstruction<a class="anchor" aria-label="anchor" href="#estimating-rates-under-a-parsimony-reconstruction"></a>
</h3>
<p>It is also possible to estimate transition rates where all nodes are
fixed in the tree. For example, what if one wanted to examine the fit of
a model where all nodes are fixed to according to a maximum parsimony
reconstruction. Here we will use <code>phangorn</code> for these
purposes. However, with <code>phangorn</code> there is the burden of
dealing with their unique <code>phyDat</code> format. To deal with this,
we implemented a function, <code><a href="../reference/ConvertPhangornReconstructions.html">ConvertPhangornReconstructions()</a></code>
that will convert the <code>phyDat</code> formatted output into
something we can modify and input into <code><a href="../reference/corHMM.html">corHMM()</a></code>.
Specifically, we can take the <code>mpr.recon</code> object from
<code>phangorn</code> and convert the output as a vector and add them as
node states in the phylogeny:</p>
<div class="sourceCode" id="cb91"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/KlausVigo/phangorn" class="external-link">phangorn</a></span><span class="op">)</span></span>
<span><span class="va">data.sort</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span><span class="va">data</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>, row.names <span class="op">=</span> <span class="va">data</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="va">data.sort</span> <span class="op">&lt;-</span> <span class="va">data.sort</span><span class="op">[</span><span class="va">phy</span><span class="op">$</span><span class="va">tip.label</span>, <span class="op">]</span></span>
<span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">as.matrix</a></span><span class="op">(</span><span class="va">data.sort</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colnames.html" class="external-link">rownames</a></span><span class="op">(</span><span class="va">dat</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="va">phy</span><span class="op">$</span><span class="va">tip.label</span></span>
<span><span class="va">dat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/as.phyDat.html" class="external-link">phyDat</a></span><span class="op">(</span><span class="va">dat</span>, type <span class="op">=</span> <span class="st">"USER"</span>, levels <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"0"</span>, <span class="st">"1"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">mpr.recon</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://klausvigo.github.io/phangorn/reference/ancestral.pml.html" class="external-link">ancestral.pars</a></span><span class="op">(</span><span class="va">phy</span>, <span class="va">dat</span>, type <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"MPR"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">mpr.recon.converted</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/ConvertPhangornReconstructions.html">ConvertPhangornReconstructions</a></span><span class="op">(</span><span class="va">mpr.recon</span><span class="op">)</span></span>
<span><span class="va">phy</span><span class="op">$</span><span class="va">node.label</span> <span class="op">&lt;-</span> <span class="va">mpr.recon.converted</span><span class="op">[</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/ape/man/summary.phylo.html" class="external-link">Ntip</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">mpr.recon.converted</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<p>Plotting the tree shows the parsimony reconstruction:</p>
<div class="sourceCode" id="cb92"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">phy</span>, cex <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/ape/man/nodelabels.html" class="external-link">nodelabels</a></span><span class="op">(</span><span class="va">phy</span><span class="op">$</span><span class="va">node.label</span><span class="op">)</span></span></code></pre></div>
<p><img src="corHMMv2.1-vignette_files/figure-html/unnamed-chunk-48-1.png" width="576" style="display: block; margin: auto;"></p>
<p>Next, input the tree into <code><a href="../reference/corHMM.html">corHMM()</a></code> and obtain a rate
estimate for this reconstruction:</p>
<div class="sourceCode" id="cb93"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fixed.parsimony.recon</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/corHMM.html">corHMM</a></span><span class="op">(</span><span class="va">phy</span>, <span class="va">data</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">]</span>, model <span class="op">=</span> <span class="st">"ER"</span>, rate.cat <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    fixed.nodes <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in corHMM(phy, data[, c(1, 2)], model = "ER", rate.cat = 1, fixed.nodes</span></span>
<span><span class="co">## = TRUE): Branch lengths of 0 detected. Adding 1e-5 to these branches.</span></span></code></pre>
<pre><code><span><span class="co">## State distribution in data:</span></span>
<span><span class="co">## States:  1   2   </span></span>
<span><span class="co">## Counts:  39  21  </span></span>
<span><span class="co">## Beginning thorough optimization search -- performing 0 random restarts </span></span>
<span><span class="co">## Finished. Inferring ancestral states using marginal reconstruction.</span></span></code></pre>
<div class="sourceCode" id="cb96"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fixed.parsimony.recon</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Fit</span></span>
<span><span class="co">##       -lnL      AIC     AICc Rate.cat ntax</span></span>
<span><span class="co">##  -53.46646 108.9329 109.0019        1   60</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Legend</span></span>
<span><span class="co">##   1   2 </span></span>
<span><span class="co">## "0" "1" </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Rates</span></span>
<span><span class="co">##            (1,R1)     (2,R1)</span></span>
<span><span class="co">## (1,R1)         NA 0.02951004</span></span>
<span><span class="co">## (2,R1) 0.02951004         NA</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Arrived at a reliable solution</span></span></code></pre>
<p>Interestingly, the parsimony reconstruction suggests a lot more
change than if we estimated the states from the model itself.</p>
</div>
<div class="section level3">
<h3 id="fixing-nodes-when-the-model-contains-hidden-states">3.3: Fixing nodes when the model contains hidden states<a class="anchor" aria-label="anchor" href="#fixing-nodes-when-the-model-contains-hidden-states"></a>
</h3>
<p>Finally, if the model contains hidden states, the user needs to fix
the state of the node based on the observed state <em>only</em>.
Remember, since we cannot actually observe hidden states, we must treat
the state of the node as ambiguous across all possible rate classes like
we would a tip. Let’s run a quick example where we fix the MRCA of
<em>Gorilla gorilla</em> and <em>Homo sapiens</em> as lacking estrus
advertisement:</p>
<div class="sourceCode" id="cb98"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">label.vector</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="fu"><a href="https://rdrr.io/pkg/ape/man/summary.phylo.html" class="external-link">Ntip</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/summary.phylo.html" class="external-link">Nnode</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">homo_gorilla</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/mrca.html" class="external-link">getMRCA</a></span><span class="op">(</span><span class="va">phy</span>, tip <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Homo_sapiens"</span>, <span class="st">"Gorilla_gorilla"</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">label.vector</span><span class="op">[</span><span class="va">homo_gorilla</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span><span class="va">phy</span><span class="op">$</span><span class="va">node.label</span> <span class="op">&lt;-</span> <span class="va">label.vector</span><span class="op">[</span><span class="op">-</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/pkg/ape/man/summary.phylo.html" class="external-link">Ntip</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="va">fix.node64.noestrus</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/corHMM.html">corHMM</a></span><span class="op">(</span><span class="va">phy</span>, <span class="va">data</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span><span class="op">]</span>, model <span class="op">=</span> <span class="st">"ARD"</span>, rate.cat <span class="op">=</span> <span class="fl">2</span>,</span>
<span>    fixed.nodes <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in corHMM(phy, data[, c(1, 2)], model = "ARD", rate.cat = 2,</span></span>
<span><span class="co">## fixed.nodes = TRUE): Branch lengths of 0 detected. Adding 1e-5 to these</span></span>
<span><span class="co">## branches.</span></span></code></pre>
<pre><code><span><span class="co">## State distribution in data:</span></span>
<span><span class="co">## States:  1   2   </span></span>
<span><span class="co">## Counts:  39  21  </span></span>
<span><span class="co">## Beginning thorough optimization search -- performing 0 random restarts </span></span>
<span><span class="co">## Finished. Inferring ancestral states using marginal reconstruction.</span></span></code></pre>
<p>Now, if we print out the line corresponding to our fixed node,</p>
<div class="sourceCode" id="cb101"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fix.node64.noestrus</span><span class="op">$</span><span class="va">states</span><span class="op">[</span><span class="va">homo_gorilla</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/summary.phylo.html" class="external-link">Ntip</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span>, <span class="op">]</span></span></code></pre></div>
<pre><code><span><span class="co">##    (1,R1)    (2,R1)    (1,R2)    (2,R2) </span></span>
<span><span class="co">## 0.8747746 0.0000000 0.1252254 0.0000000</span></span></code></pre>
<p>there should be some uncertainty as to whether the absence of estrus
advertisement is in R1 or R2. The total probability, however, of the
node being in observed state 1 should sum to 1:</p>
<div class="sourceCode" id="cb103"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">fix.node64.noestrus</span><span class="op">$</span><span class="va">states</span><span class="op">[</span><span class="va">homo_gorilla</span> <span class="op">-</span> <span class="fu"><a href="https://rdrr.io/pkg/ape/man/summary.phylo.html" class="external-link">Ntip</a></span><span class="op">(</span><span class="va">phy</span><span class="op">)</span>, <span class="op">]</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 1</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h3>
<p>Beaulieu J.M., B.C. O’Meara, and M.J. Donoghue. 2013. Identifying
hidden rate changes in the evolution of a binary morphologicalcharacter:
the evolution of plant habit in campanulid angiosperms. Systematic
Biology 62:725-737.</p>
<p>Marazzi B., Ane C., Simon M.F., Delgado-Salinas A., Luckow M.,
Sanderson M.J. 2012. Locating Evolutionary Precursors on a Phylogenetic
Tree. Evolution. 66:3918-3930.</p>
<p>Pagel, M. 1994. Detecting correlated evolution on phylogenies: a
general method for the comparative analysis of discrete characters.
Proceedings of the Royal Society, B. 255:37-45.</p>
<p>Pagel, M., and A. Meade. 2006. Bayesian analysis of correlated
evolution of discrete characters by reversible-jump Markov chain Monte
Carlo. American Naturalist 167:808:825.</p>
<p>Roman-Palacios C., Scholl J.P., Wiens J.J. 2019. Evolution of diet
across the animal tree of life. Evolution Letters. 3:339-347.</p>
<p>Sackton, T.B., P. Grayson, A. Cloutier, Z. Hu, J.S. Liu, N.E.
Wheeler, P.P. Gardner, J.A. Clarke, A.J. Baker, M. Clamp, and S.V.
Edwards. 2019. Convergent regulatory evolution and loss of flight in
paleognathous birds. Science 364:74-78.</p>
<p>Zucchini W., MacDonald I.L., Langrock R. 2017. Hidden Markov models
for time series: an introduction using R. Chapman and Hall/CRC.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p></p>
<p>Developed by Jeremy Beaulieu, Brian O’Meara, Jeffrey Oliver, James Boyko.</p>
</div>

<div class="pkgdown">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer>
</div>

  


  

  </body>
</html>
